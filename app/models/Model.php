<?php
namespace Model;

class Model extends \Phalcon\Mvc\Model {
    const DELETE_TRUE   = 1;
    const DELETE_FALSE  = 0;

    static private function _getArray($array) {
        return $array;
    }

    static private function _getString($array, $key, $result = true) {
        return isset($array[$key])
            ? $array[$key]
            : ($result ? $key : null);
    }

    static public function __callStatic($method, $arguments) {
        if(preg_match('@^get(.*)?(Array|String)$@u', $method, $match)) {
            preg_match_all('@([A-Z]+[a-z0-9]+)@u', $match[1], $matches);

            $a = array_map(function($value) {
                return mb_strtolower($value);
            }, $matches[0]);

            $var = implode('_', $a);
            if(isset(static::$_)) {
                if(isset(static::$_[$var])) {
                    switch($match[2]) {
                        case 'Array':
                            return forward_static_call_array(['\Model\Model', '_getArray'], array_merge(
                                [
                                    static::$_[$var]
                                ],
                                $arguments
                            ));
                            break;

                        case 'String':
                            return forward_static_call_array(['\Model\Model', '_getString'], array_merge(
                                [
                                    static::$_[$var]
                                ],
                                $arguments
                            ));
                            break;

                        default:
                            break;
                    }
                }
            }
        }

        parent::__callStatic($method, $arguments); // TODO: Change the autogenerated stub
    }

    /**
     * Mapper колонок для Model\Complex
     *
     * @param $model Модель
     * @param $name Алиас модели
     * @return array
     */
    static public function ComplexMapper($model, $name) {
        $array = [];

        foreach((new self())->getModelsMetaData()->getAttributes(new $model()) as $col) {
            $array[$col] = "{$name}.{$col} AS _{$name}_{$col}";
        }

        return [$array, $model];
    }

    /**
     * Создание \Phalcon\Mvc\Model\Resultset\Complex из массива с параметрами для SQL
     *
     * @param array $params
     * @param bool $count
     * @return \Phalcon\Mvc\Model\Resultset\Complex
     */
    static public function ComplexQueryBuilder(array $params, $count = false) {
        $sql_part = [];
        $sql_part['select'] = "SELECT";

        // colums
        $tmp = [];
        if(is_array($params['columns'])) {
            foreach($params['columns'] as $key => $value) {
                $tmp[] = "{$value}" . (!is_numeric($key) ? " AS {$key}" : '');
            }
        }

        if($count) {
            $tmp[] = 'COUNT(*) AS count';
        }
        else {
            foreach($params['from'] as $from) {
                foreach($from as $value) {
                    $tmp[] = $params['map'][$value] ? implode(', ', $params['map'][$value]) : "{$value}.*";
                }
            }

            if(is_array($params['inner_join'])) {
                foreach ($params['inner_join'] as $innerJoin) {
                    foreach ($innerJoin[0] as $value) {
                        $tmp[] = $params['map'][$value] ? implode(', ', $params['map'][$value]) : "{$value}.*";
                        break;
                    }
                }
            }

            if(is_array($params['left_join'])) {
                foreach($params['left_join'] as $leftJoin) {
                    foreach($leftJoin[0] as $value) {
                        $tmp[] = $params['map'][$value] ? implode(', ', $params['map'][$value]) : "{$value}.*";
                        break;
                    }
                }
            }
        }
        $sql_part['columns'] = implode(', ', $tmp);

        // from
        $tmp = [];
        foreach($params['from'] as $from) {
            foreach($from as $key => $value) {
                $tmp[] = "{$value}" . (!is_numeric($key) ? " AS {$key}" : '');
            }
        }
        $sql_part['from'] = 'FROM ' . implode(', ', $tmp);

        // inner join
        $sql_part['inner_join'] = [];
        if(is_array($params['inner_join'])) {
            foreach($params['inner_join'] as $innerJoin) {
                $tmp = '';

                foreach($innerJoin[0] as $key => $value) {
                    $tmp = "INNER JOIN {$value}" . (!is_numeric($key) ? " AS {$key}" : '');
                    break;
                }

                $tmp .= " ON ({$innerJoin[1]})";
                $sql_part['inner_join'][] = $tmp;
            }
        }

        // left join
        $sql_part['left_join'] = [];
        if(is_array($params['left_join'])) {
            foreach($params['left_join'] as $leftJoin) {
                $tmp = '';

                foreach($leftJoin[0] as $key => $value) {
                    $tmp = "LEFT JOIN {$value}" . (!is_numeric($key) ? " AS {$key}" : '');
                    break;
                }

                $tmp .= " ON ({$leftJoin[1]})";
                $sql_part['left_join'][] = $tmp;
            }
        }

        // where
        $sql_part['where'] = count($params['where']) ? 'WHERE ' . implode(' AND ', $params['where']) : '';

        // order
        $sql_part['order'] = count($params['order']) ? 'ORDER BY ' . implode(', ', $params['order']) : '';

        // limit
        $tmp = '';
        if(is_numeric($params['limit'])) {
            $tmp = "{$params['limit']}";
        }
        elseif(is_array($params['limit'])) {
            $tmp = "{$params['limit'][0]}, {$params['limit'][1]}";
        }

        $sql_part['limit'] = $tmp ? "LIMIT {$tmp}" : '';

        $sql = "{$sql_part['select']}
{$sql_part['columns']}
{$sql_part['from']}
" . implode(' ', $sql_part['inner_join']) . "
" . implode(' ', $sql_part['left_join']) . "
{$sql_part['where']}
{$sql_part['order']}
{$sql_part['limit']};";

        $rows = (new self())->getReadConnection()->query($sql, $params['bind']);

        $complex = [];

        if(is_array($params['columns'])) {
            foreach ($params['columns'] as $key => $value) {
                $complex[$key] = [
                    'sqlAlias' => $key,
                    'balias' => $key,
                ];
            }
        }

        if($count) {
            $complex['count'] = [
                'sqlAlias' => 'count',
                'balias' => 'count',
            ];
        }
        else {
            if(is_array($params['map'])) {
                foreach($params['map'] as $key => $value) {
                    $complex[$key] = [
                        'type' => 'object',
                        'column' => $key,
                        'attributes' => array_keys($value),
                        'instance' => new $params['model'][$key](),
                        'balias' => $key,
                    ];
                }
            }
        }

        return new \Phalcon\Mvc\Model\Resultset\Complex($complex, $rows);
    }

    public function initialize() {
        $this->useDynamicUpdate(true);
    }

    public function beforeValidationOnCreate() {
        $metaData = $this->getModelsMetaData();
        $attributes = $metaData->getNotNullAttributes($this);

        // Set all not null fields to their default value.
        foreach($attributes as $field) {
            if(!isset($this->{$field}) && is_null($this->{$field})) {
                $this->{$field} = new \Phalcon\Db\RawValue('default');
            }
        }
    }

}
